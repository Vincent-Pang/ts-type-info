var gulp = require("gulp");
var del = require("del");
var dtsGenerator = require("dts-generator");
var mocha = require("gulp-mocha");
var ts = require("gulp-typescript");
var tslint = require("gulp-tslint");
var sourcemaps = require("gulp-sourcemaps");
var CodeBlockWriter = require("code-block-writer").default;
var p = require("./package.json");
var fs = require("fs");
var path = require("path");

gulp.task("typescript", ["clean-scripts"], function() {
    var tsProject = ts.createProject("tsconfig.json", {
        typescript: require("typescript")
    });

    return gulp.src(["./src/typings/**/*.d.ts", "./src/**/*.ts"])
        .pipe(sourcemaps.init())
        .pipe(ts(tsProject))
        .pipe(sourcemaps.write("./"))
        .pipe(gulp.dest("./dist"));
});

// base for generation. Not accurate, so not used
gulp.task("dts-generator", ["clean-scripts"], function(cb) {
    dtsGenerator.generate({
        name: p.name,
        main: p.name + "/main",
        baseDir: './src',
        files: ['main.ts', '../node_modules/typescript/lib/typescript.d.ts'],
        excludes: [
           "node_modules/**/*.d.ts",
            "utils/type-guards.ts",
            "utils/decorators.ts",
            "utils/type-checker.ts",
            "utils.ts"
        ],
        out: "./dist/" + p.name + ".d.ts"
    });
    cb();
});

gulp.task("generate-definition-file", ["typescript"], function(cb) {
    // use this library to generate the definition file
    var writer = new CodeBlockWriter();
    var tsTypeInfo = require("./dist/main");
    var Scope = require("./dist/scope").Scope;
    var fileInfo = tsTypeInfo.getFileInfo(["./src/definitions.ts"]);
    var definitionClasses = [];
    var foundClassNames = [];

    fileInfo.forEach(function(f) {
        f.classes.forEach(function(c) {
            if ((c.name.match(/Definition$/) || c.name === "Type") && foundClassNames.indexOf(c.name) === -1) {
                foundClassNames.push(c.name)
                definitionClasses.push(c);
            }
        })
    });

    writer.write("// auto-generated by generate-definition-file\n");
    writer.write("declare module \"ts-type-info\"").block(function() {
        definitionClasses.forEach(function(c) {
            var extendsClause = "";
            if (c.baseClasses.length > 0) {
                extendsClause += " extends ";
                c.baseClasses.forEach(function(b, i) {
                    if (i != 0) {
                        extendsClause += ", ";
                    }
                    extendsClause += b.name;
                });
            }

            writer.write("class " + c.name + extendsClause).block(function() {
                c.properties.forEach(function(p) {
                    if (p.scope === Scope.public && p.name.indexOf("fill") !== 0 && p.name !== "tsType") {
                        writer.writeLine(p.name + ": " + p.type.name + ";");
                    }
                });
            }).newLine();
        });

        writer.write("export enum Scope").block(function() {
            writer.writeLine("public,");
            writer.writeLine("protected,");
            writer.writeLine("private");
        });
        writer.newLine();
        writer.write("export function getFileInfo(fileNames: string[]): FileDefinition[];");
    });

    fs.writeFile(path.join(__dirname, "ts-type-info.d.ts"), writer.toString(), function(err) {
        if (err) throw err;
        cb();
    });
});

gulp.task("test", ["typescript"], function() {
    return gulp.src("dist/tests/**/*.js")
        .pipe(mocha({ reporter: "progress" }));
});

gulp.task("tslint", function() {
    return gulp.src(["./src/**/*.ts", "!./src/typings/**/*.d.ts"])
        .pipe(tslint())
        .pipe(tslint.report("verbose"));
});

gulp.task("watch", function() {
    gulp.watch("./src/**/*.ts", ["tslint", "typescript"]);
});

gulp.task("clean-scripts", function(cb) {
    return del(["./dist/**/*{.js,.js.map}"], cb);
});

gulp.task("default", ["tslint", "typescript", "generate-definition-file"]);