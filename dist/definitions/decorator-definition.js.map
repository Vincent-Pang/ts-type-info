{"version":3,"sources":["definitions/decorator-definition.ts"],"names":["DecoratorDefinition","DecoratorDefinition.constructor","DecoratorDefinition.name","DecoratorDefinition.arguments","DecoratorDefinition.fillName","DecoratorDefinition.fillArguments"],"mappings":";;;;;;;;AACA,4BAAiC,kBAAkB,CAAC,CAAA;AACpD,sBAAuC,YAAY,CAAC,CAAA;AAEpD;IAIIA,6BAAYA,SAAuBA;QAF3BC,eAAUA,GAAyBA,EAAEA,CAACA;QAG1CA,IAAIA,mBAAmBA,GAAGA,SAASA,CAACA,UAAUA,CAACA;QAE/CA,IAAIA,CAACA,QAAQA,CAACA,mBAAmBA,CAACA,CAACA;QAEnCA,EAAEA,CAACA,CAACA,kBAAUA,CAACA,gBAAgBA,CAACA,mBAAmBA,CAACA,CAACA,CAACA,CAACA;YACnDA,IAAIA,CAACA,aAAaA,CAACA,mBAAmBA,CAACA,SAASA,CAACA,CAACA;QACtDA,CAACA;IACLA,CAACA;IAEDD,sBACIA,qCAAIA;aADRA;YAEIE,MAAMA,CAACA,IAAIA,CAACA,KAAKA,CAACA;QACtBA,CAACA;;;OAAAF;IAEDA,sBACIA,0CAASA;aADbA;YAEIG,MAAMA,CAACA,IAAIA,CAACA,UAAUA,CAACA;QAC3BA,CAACA;;;OAAAH;IAEOA,sCAAQA,GAAhBA,UAAiBA,mBAA8CA;QAC3DI,EAAEA,CAACA,CAACA,kBAAUA,CAACA,mBAAmBA,CAACA,mBAAmBA,CAACA,CAACA,CAACA,CAACA;YACtDA,IAAIA,CAACA,KAAKA,GAAGA,mBAAmBA,CAACA,IAAIA,CAACA;QAC1CA,CAACA;QACDA,IAAIA,CAACA,EAAEA,CAACA,CAACA,mBAAmBA,IAAIA,IAAIA,CAACA,CAACA,CAACA;YACnCA,IAAIA,CAACA,QAAQA,CAAEA,mBAA2BA,CAACA,YAAYA,CAAyBA,CAACA,CAACA;QACtFA,CAACA;QACDA,IAAIA,CAACA,CAACA;YACFA,MAAMA,8CAA8CA,CAACA;QACzDA,CAACA;IACLA,CAACA;IAEOJ,2CAAaA,GAArBA,UAAsBA,IAAiCA;QACnDK,GAAGA,CAACA,CAAYA,UAAIA,EAAfA,gBAAOA,EAAPA,IAAeA,CAACA;YAAhBA,IAAIA,GAAGA,GAAIA,IAAIA,IAARA;YACRA,IAAIA,CAACA,UAAUA,CAACA,IAAIA,CAACA,IAAIA,gCAAkBA,CAACA,GAAGA,CAACA,CAACA,CAACA;SACrDA;IACLA,CAACA;IA1BDL,sBACIA,qCAAIA;;YADPA,oBAAYA;WACTA,qCAAIA,kCAAJA,qCAAIA,IAEPA;IAEDA,sBACIA,0CAASA;;YADZA,oBAAYA;WACTA,0CAASA,kCAATA,0CAASA,IAEZA;IAmBLA,0BAACA;AAADA,CAzCA,AAyCCA,IAAA;AAzCY,2BAAmB,sBAyC/B,CAAA","file":"definitions/decorator-definition.js","sourcesContent":["import * as ts from \"typescript\";\r\nimport {ArgumentDefinition} from \"./../definitions\";\r\nimport {TypeGuards, Serializable} from \"./../utils\";\r\n\r\nexport class DecoratorDefinition {\r\n    private _name: string;\r\n    private _arguments: ArgumentDefinition[] = [];\r\n\r\n    constructor(decorator: ts.Decorator) {\r\n        let decoratorExpression = decorator.expression;\r\n\r\n        this.fillName(decoratorExpression);\r\n\r\n        if (TypeGuards.isCallExpression(decoratorExpression)) {\r\n            this.fillArguments(decoratorExpression.arguments);\r\n        }\r\n    }\r\n\r\n    @Serializable\r\n    get name() {\r\n        return this._name;\r\n    }\r\n\r\n    @Serializable\r\n    get arguments() {\r\n        return this._arguments;\r\n    }\r\n\r\n    private fillName(decoratorExpression: ts.LeftHandSideExpression) {\r\n        if (TypeGuards.isLiteralExpression(decoratorExpression)) {\r\n            this._name = decoratorExpression.text;\r\n        }\r\n        else if (decoratorExpression != null) {\r\n            this.fillName((decoratorExpression as any)[\"expression\"] as ts.LiteralExpression);\r\n        }\r\n        else {\r\n            throw \"Unhandled: The decorator expression was null\";\r\n        }\r\n    }\r\n\r\n    private fillArguments(args: ts.NodeArray<ts.Expression>) {\r\n        for (let arg of args) {\r\n            this._arguments.push(new ArgumentDefinition(arg));\r\n        }\r\n    }\r\n}\r\n"],"sourceRoot":"/source/"}