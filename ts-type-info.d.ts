// auto-generated by: gulp generate-definition-file
declare module "ts-type-info" {
    export interface Options {
        compilerOptions: CompilerOptions;
    }

    export interface CompilerOptions {
        allowNonTsExtensions: boolean;
        charset: string;
        locale: string;
        project: string;
        rootDir: string;
    }

    export interface IBaseNamedDefinition {
        name: string;
    }

    export interface INamedDefinition extends IBaseNamedDefinition {
    }

    export interface ITypeExpressionedDefinition {
        typeExpression: TypeExpression;
    }

    export interface IScopedDefinition {
        scope: Scope;
    }

    export interface IDecoratableDefinition {
        decorators: DecoratorDefinition[];
    }

    export interface IExportableDefinition {
        isExported: boolean;
    }

    export interface IModuledDefinition {
        classes: ClassDefinition[];
        interfaces: InterfaceDefinition[];
        enums: EnumDefinition[];
        functions: FunctionDefinition[];
        namespaces: NamespaceDefinition[];
    }

    export interface ITypeParameteredDefinition {
        typeParameters: TypeParameterDefinition[];
    }

    export interface BaseParameterDefinitionConstructor<T> {
    }

    export interface IParameteredDefinition<T> {
        parameters: T[];
    }

    export interface IReturnTypedDefinition {
        returnTypeExpression: TypeExpression;
    }

    export class NamedDefinition {
        name: string;
    }

    export class TypeExpressionedDefinition {
        typeExpression: TypeExpression;
    }

    export class ScopedDefinition {
        scope: Scope;
    }

    export class DecoratableDefinition {
        decorators: DecoratorDefinition[];
    }

    export class ExportableDefinition {
        isExported: boolean;
    }

    export class ModuledDefinition {
        namespaces: NamespaceDefinition[];
        classes: ClassDefinition[];
        enums: EnumDefinition[];
        functions: FunctionDefinition[];
        interfaces: InterfaceDefinition[];
    }

    export class PropertyDefinition {
        isOptional: boolean;
        name: string;
        typeExpression: TypeExpression;
    }

    export class TypeParameterDefinition {
        constraintTypeExpression: TypeExpression;
        name: string;
    }

    export class TypeParameteredDefinition {
        typeParameters: TypeParameterDefinition[];
    }

    export class DecoratorDefinition {
        name: string;
        arguments: Expression[];
    }

    export class BaseFunctionDefinition<T> {
        name: string;
        parameters: T[];
        returnTypeExpression: TypeExpression;
        typeParameters: TypeParameterDefinition[];
    }

    export class BaseParameterDefinition {
        isOptional: boolean;
        isRestParameter: boolean;
        defaultExpression: Expression;
        name: string;
        typeExpression: TypeExpression;
    }

    export class ParameteredDefinition<T> {
        parameters: T[];
    }

    export class ReturnTypedDefinition {
        returnTypeExpression: TypeExpression;
    }

    export class CallSignatureDefinition {
        minArgumentCount: number;
        parameters: ParameterDefinition[];
        returnTypeExpression: TypeExpression;
        typeParameters: TypeParameterDefinition[];
    }

    export class FunctionDefinition extends BaseFunctionDefinition<ParameterDefinition> {
        isExported: boolean;
    }

    export class ParameterDefinition extends BaseParameterDefinition {
    }

    export class BaseClassMethodDefinition extends BaseFunctionDefinition<ClassMethodParameterDefinition> {
        decorators: DecoratorDefinition[];
        scope: Scope;
    }

    export class BaseClassPropertyDefinition extends PropertyDefinition {
        decorators: DecoratorDefinition[];
        scope: Scope;
    }

    export class ClassDefinition {
        methods: ClassMethodDefinition[];
        properties: ClassPropertyDefinition[];
        staticMethods: ClassStaticMethodDefinition[];
        staticProperties: ClassStaticPropertyDefinition[];
        constructorDef: ConstructorDefinition;
        typeParameters: TypeParameterDefinition[];
        extendsTypeExpressions: TypeExpression[];
        implementsTypeExpressions: TypeExpression[];
        name: string;
        decorators: DecoratorDefinition[];
        isExported: boolean;
    }

    export class ClassMethodDefinition extends BaseClassMethodDefinition {
    }

    export class ClassMethodParameterDefinition extends BaseParameterDefinition {
        decorators: DecoratorDefinition[];
    }

    export class ClassPropertyDefinition extends BaseClassPropertyDefinition {
        isAccessor: boolean;
        isReadonly: boolean;
    }

    export class ConstructorDefinition {
        parameters: ClassMethodParameterDefinition[];
    }

    export class ClassStaticMethodDefinition extends BaseClassMethodDefinition {
    }

    export class ClassStaticPropertyDefinition extends BaseClassPropertyDefinition {
    }

    export class InterfaceDefinition {
        methods: InterfaceMethodDefinition[];
        newSignatures: InterfaceNewSignatureDefinition[];
        properties: PropertyDefinition[];
        typeParameters: TypeParameterDefinition[];
        extendsTypeExpressions: TypeExpression[];
        name: string;
        isExported: boolean;
    }

    export class InterfaceMethodDefinition extends BaseFunctionDefinition<ParameterDefinition> {
    }

    export class InterfaceNewSignatureDefinition {
        parameters: ParameterDefinition[];
        returnTypeExpression: TypeExpression;
    }

    export class EnumDefinition {
        members: EnumMemberDefinition[];
        name: string;
        isExported: boolean;
    }

    export class EnumMemberDefinition {
        value: number;
        name: string;
    }

    export class NamespaceDefinition {
        name: string;
        classes: ClassDefinition[];
        interfaces: InterfaceDefinition[];
        enums: EnumDefinition[];
        functions: FunctionDefinition[];
        namespaces: NamespaceDefinition[];
        isExported: boolean;
    }

    export class FileDefinition {
        fileName: string;
        imports: ImportDefinition[];
        reExports: ReExportDefinition[];
        name: string;
        classes: ClassDefinition[];
        interfaces: InterfaceDefinition[];
        enums: EnumDefinition[];
        functions: FunctionDefinition[];
        namespaces: NamespaceDefinition[];
    }

    export class ImportDefinition {
        file: FileDefinition;
        definition: IBaseNamedDefinition & IExportableDefinition;
    }

    export class ReExportDefinition {
        file: FileDefinition;
        definition: IBaseNamedDefinition & IExportableDefinition;
    }

    export class Expression {
        text: string;
    }

    export class Type {
        text: string;
        properties: PropertyDefinition[];
        callSignatures: CallSignatureDefinition[];
        definition: IBaseNamedDefinition;
        typeArguments: TypeExpression[];
    }

    export class TypeExpression {
        text: string;
        types: Type[];
    }

    export enum Scope {
        public = 0,
        protected = 1,
        private = 2
    }

    export function getFileInfo(fileNames: string[], options?: Options): FileDefinition[];
    export function getStringInfo(code: string, options?: Options): FileDefinition;
}
